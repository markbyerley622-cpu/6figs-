<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RetardioStrategy‚Ñ¢ Dashboard</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <!-- Particle background -->
  <canvas id="orbCanvas"></canvas>

  <!-- === Phantom Connect Button === -->
  <div id="wallet-connect-container">
    <button id="connect-wallet-btn">Connect Wallet</button>
    <p id="wallet-address-display"></p>
  </div>

<!-- === Follow X Button === -->
<div id="follow-x-container">
  <button id="follow-x-btn" onclick="window.open('https://x.com/retardioostr', '_blank')">
    Follow X
  </button>

 <!-- === Aesthetic Non-Functional Button === -->
  <button class="aesthetic-btn" disabled>Compatible for all devices</button>
</div>


  <div class="dashboard">
    <h1>RetardioStrategy‚Ñ¢</h1>
    <h2>NFTStrategy (Solana Edition)</h2>
    <p class="contract">Contract: <span id="contract">Coming soon...</span></p>


<!-- === Project Description === -->
<div class="project-description">
  <img src="retardiologo.png" alt="$RTRDSTR Logo" class="project-logo" />
  <p>
    <strong>$RTRDSTR Machine</strong><br>
    Built on the Solana blockchain, the $RTRDSTR Machine powers the RETARDIO NFT ecosystem. 
    Creator fees generated by the $RTRDSTR token will be used to purchase RETARDIO NFTs from the floor. 
    These NFTs will then be relisted at <strong>1.2√ó</strong> the purchase price. 
    Proceeds from the sales will be used to buy back and burn $RTRDSTR tokens, supporting 
    <strong>deflationary tokenomics</strong>.
  </p>
</div>


    <!-- === Stats === -->
    <div class="stats">
      <div class="stat"><span class="label">Holding</span><span id="holding">0 Retardios</span></div>
      <div class="stat"><span class="label">SOL Price</span><span id="sol-price">$0.00</span></div>
      <div class="stat"><span class="label">$RTSTRDGY Price</span><span id="token-price">$0.0000</span></div>
      <div class="stat"><span class="label">Liquidity</span><span id="market-cap">$0.00M</span></div>
      <div class="stat"><span class="label">24h Change</span><span id="change">-0.00%</span></div>
    </div>

    <!-- === Treasury Section === -->
    <div class="treasury">
      <h3>Treasury Holdings</h3>
      <p>Treasury: <a id="Treasury" href="#" target="_blank">Insert wallet address here</a></p>
      <p>NFTs held: <span id="nft-count">0</span></p>
    </div>

 <!-- === Progress Section === -->
<div class="progress-section">
  <h3>Progress to Next Purchase</h3>

  <!-- Hidden input for Next Purchase uploads -->
  <input type="file" id="next-nft-upload" accept="image/*" style="display:none">

  <!-- Where the uploaded NFT will appear -->
  <div id="next-nft-preview" class="next-nft">
    <p>No next NFT uploaded yet.</p>
  </div>

  <div class="progress-bar">
    <div class="progress-fill" id="progress-fill" style="width: 0%;"></div>
  </div>

  <p id="progress-percent">0%</p>

  <p>
    When the machine acquires the missing
    <span id="missing-sol">0.0000</span> SOL, the entity to trigger the mechanism will process
    the purchase from floor price, which will be held by the treasury and relisted.
  </p>

  <p><strong>Need:</strong> <span id="need-sol">0.000</span> more SOL</p>
</div>



<iframe
  id="gecko-frame"
  src="https://www.geckoterminal.com/solana/pools/5eLRsN6qDQTQSBF8KdW4B8mVpeeAzHCCwaDptzMyszxH?embed=1"
  width="100%"
  height="500"
  style="border:0; border-radius:12px; overflow:hidden;"
  allowfullscreen
></iframe>




   <!-- === Treasury NFT Gallery === -->
   <div class="gallery">
     <div class="gallery-header">
       <h3>Treasury NFT Gallery</h3>
       <a href="https://magiceden.io/marketplace/retardio_cousins" target="_blank">
         <img src="magiceden-logo.png" alt="Magic Eden" class="magic-eden-logo" />
       </a>
     </div>

     <p id="gallery-summary">RetardioStrategy‚Ñ¢ is currently holding 0 NFTs</p>
     <input type="file" id="nft-upload" accept="image/*" style="display:none" multiple />
     <div id="gallery-grid" class="gallery-grid"></div>
   </div>

   <!-- === Token Loader (Hidden) === -->
   <div id="token-loader" style="display:none; margin:20px 0;">
     <label for="token-contract">Paste DexScreener/Token CA:</label>
     <input type="text" id="token-contract" placeholder="Enter contract address or token symbol" />
     <button id="load-token">Load Token</button>
   </div>

   <!-- === Dev Panel (Hidden by Default) === -->
   <div id="dev-panel" style="display:none;">
     <button id="u1" class="dev-btn">u1</button>
     <button id="s1" class="dev-btn">s1</button>
     <button id="pa" class="dev-btn">pa</button>
     <button id="np" class="dev-btn">NP</button>
     <button id="ba" class="dev-btn">BA</button> <!-- üî• Burn Amount -->
   </div>

 <!-- === Sold NFT Gallery === -->
<div class="gallery sold-gallery">
  <div class="gallery-header">
    <h3>Sold NFTs</h3>
  </div>

  <p id="sold-summary">RetardioStrategy‚Ñ¢ has sold 0 NFTs</p>
 <p>Burned Amount: <span id="burned-percent">0%</span></p>
  <input type="file" id="sold-upload" accept="image/*" style="display:none" multiple />
  <div id="sold-gallery-grid" class="gallery-grid"></div>
</div>


<!-- === JS === -->
<script>

async function loadPoolChart() {
  try {
    const ohlcvRes = await fetch(
      `https://api.geckoterminal.com/api/v2/networks/solana/pools/${poolId}/ohlcv/hour`
    );

    if (ohlcvRes.status === 404) {
      console.warn("No OHLCV data for this pool ‚Äî showing current price instead");
      const poolRes = await fetch(
        `https://api.geckoterminal.com/api/v2/networks/solana/pools/${poolId}`
      );
      const poolData = await poolRes.json();
      const price = poolData?.data?.attributes?.base_token_price_usd;
      chartDiv.innerHTML = `<div style="font-size:2rem;color:#ff4fd8;text-align:center;">$${Number(price).toFixed(4)}</div>`;
      return;
    }

    if (!ohlcvRes.ok) throw new Error(`HTTP ${ohlcvRes.status}`);
    const data = await ohlcvRes.json();
    const prices = data?.data?.attributes?.ohlcv_list;

    if (!prices) throw new Error("No OHLCV data");

    const chartData = prices.map(([timestamp, open, high, low, close]) => ({
      time: Math.floor(new Date(timestamp).getTime() / 1000),
      open: +open,
      high: +high,
      low: +low,
      close: +close
    }));

    candleSeries.setData(chartData);
  } catch (err) {
    chartDiv.innerHTML = "‚ö†Ô∏è Failed to load chart.";
    console.error("Error loading chart:", err);
  }
}

// === Dev Unlock (Ctrl+D) ===
window.addEventListener("keydown", async (e) => {
  if (e.ctrlKey && e.key.toLowerCase() === "d") {
    const key = prompt("Enter developer key:");
    if (!key) return;

    try {
      const res = await fetch("/verify-dev", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ key }),
      });
      const data = await res.json();

      if (data.valid) {
        devUnlocked = true;
        document.getElementById("dev-panel").style.display = "flex";
        alert("Developer mode unlocked üîì");
      } else {
        alert("Access denied üö´");
      }
    } catch (err) {
      console.error("Dev verify failed:", err);
      alert("Server error ‚ùå");
    }
  }
});

// === u1 (Upload Treasury NFTs - GLOBAL) ===
document.getElementById("u1").addEventListener("click", () => {
  if (!devUnlocked) return alert("üö´ Developer mode required.");
  const fileInput = document.getElementById("nft-upload");
  fileInput.click();

  fileInput.onchange = async () => {
    const formData = new FormData();

    for (const file of fileInput.files) {
      const name = prompt("Enter NFT Name:");
      const price = prompt("Enter Listing Price (SOL):");
      const magicEdenUrl = prompt("Enter Magic Eden item URL (optional):", "https://magiceden.io/item-details/");

      formData.append("images", file);
      formData.append(
        "meta",
        JSON.stringify({ name, price, magicEdenUrl })
      );
    }

    const res = await fetch("/upload-gallery", {
      method: "POST",
      body: formData,
    });
    const data = await res.json();

    if (data.success) {
      alert("‚úÖ Treasury NFT uploaded globally!");
      loadGallery();
    } else {
      alert("‚ùå Upload failed.");
    }
  };
});


  // === s1 (Upload Sold NFTs - GLOBAL) ===
  document.getElementById("s1").addEventListener("click", () => {
    if (!devUnlocked) return alert("üö´ Developer mode required.");
    const fileInput = document.getElementById("sold-upload");
    fileInput.click();
    fileInput.onchange = async () => {
      const formData = new FormData();
      for (const file of fileInput.files) {
        const name = prompt("Enter Sold NFT Name:");
        const price = prompt("Enter Sold Price (SOL):");
        formData.append("images", file);
        formData.append("meta", JSON.stringify({ name, price }));
      }
      const res = await fetch("/upload-sold", { method: "POST", body: formData });
      const data = await res.json();
      if (data.success) {
        alert("‚úÖ Sold NFT uploaded globally!");
        loadSoldGallery();
      } else {
        alert("‚ùå Upload failed.");
      }
    };
  });

// === BA (Burn Amount - Set Burned % Display) ===
document.getElementById("ba").addEventListener("click", () => {
  if (!devUnlocked) return alert("üö´ Developer mode required.");

  // Ask the dev for a burn % (number only)
  const value = prompt("Enter Burned Percentage (0-100):", "0");
  if (value === null) return; // cancelled
  const percent = parseFloat(value);

  if (isNaN(percent) || percent < 0 || percent > 100) {
    alert("‚ùå Invalid value. Please enter a number between 0 and 100.");
    return;
  }

  // Save locally so it persists between reloads
  localStorage.setItem("burnPercent", percent);

  // Update UI immediately
  document.getElementById("burned-percent").textContent = `${percent}% üî•`;

  alert(`üî• Burn percentage updated to ${percent}%`);
});



function launchConfetti() {
  const duration = 10000;
  const animationEnd = Date.now() + duration;
  const defaults = { startVelocity: 25, spread: 360, ticks: 60, zIndex: 9999 };

  function randomInRange(min, max) {
    return Math.random() * (max - min) + min;
  }

  (function frame() {
    // Use a CDN-free version if you already have canvas-confetti
    if (typeof confetti === "function") {
      confetti({
        ...defaults,
        particleCount: 50,
        origin: {
          x: randomInRange(0.1, 0.9),
          y: Math.random() - 0.2,
        },
      });
    }
    if (Date.now() < animationEnd) {
      requestAnimationFrame(frame);
    }
  })();
}


  // === Purple Orbs Background ===
  const canvas = document.getElementById("orbCanvas");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();

  // Available orb colors
  const orbColors = [
    { color: "#FF4FD8", glow: "#FF4FD8" }, // Original purple-pink
    { color: "#9945FF", glow: "#9945FF" }, // Solana purple
    { color: "#14F195", glow: "#14F195" }  // Solana green
  ];

  class Orb {
    constructor() {
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.size = 40 + Math.random() * 60;
      this.dx = (Math.random() - 0.5) * 0.5;
      this.dy = (Math.random() - 0.5) * 0.5;
      this.opacity = 0.1 + Math.random() * 0.2;

      // Random color from Solana + original palette
      const chosen = orbColors[Math.floor(Math.random() * orbColors.length)];
      this.baseColor = chosen.color;
      this.glowColor = chosen.glow;
    }

    draw() {
      ctx.beginPath();
      ctx.fillStyle = `${this.hexToRgba(this.baseColor, this.opacity)}`;
      ctx.shadowColor = this.glowColor;
      ctx.shadowBlur = 40;
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    update() {
      this.x += this.dx;
      this.y += this.dy;
      if (this.x < 0 || this.x > canvas.width) this.dx *= -1;
      if (this.y < 0 || this.y > canvas.height) this.dy *= -1;
      this.draw();
    }

    // Helper to convert hex ‚Üí rgba
    hexToRgba(hex, alpha) {
      const bigint = parseInt(hex.slice(1), 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
  }

  const orbs = Array.from({ length: 15 }, () => new Orb());

  function animate() {
    ctx.fillStyle = "rgba(10,0,10,0.3)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    orbs.forEach((o) => o.update());
    requestAnimationFrame(animate);
  }

  animate();
  window.addEventListener("resize", resizeCanvas);
</script>

<!-- === Phantom Wallet Connect === -->
<script>
const connectBtn = document.getElementById("connect-wallet-btn");
const walletDisplay = document.getElementById("wallet-address-display");

// --- Connect Phantom ---
async function connectPhantom() {
  try {
    if (!window.solana || !window.solana.isPhantom) {
      alert("Phantom Wallet not found. Please install it from https://phantom.app/");
      return;
    }

    const resp = await window.solana.connect();
    const address = resp.publicKey.toString();

    walletDisplay.textContent = address.slice(0, 4) + "..." + address.slice(-4);
    connectBtn.textContent = "Disconnect ‚ùå";
    connectBtn.dataset.connected = "true"; // Track connection state
    connectBtn.style.opacity = 0.8;

    localStorage.setItem("phantomWallet", address);
    console.log("Connected wallet:", address);
  } catch (err) {
    console.error("Connection failed:", err);
    alert("Wallet connection failed or rejected.");
  }
}

// --- Disconnect Phantom ---
async function disconnectPhantom() {
  try {
    if (window.solana && window.solana.isPhantom) {
      await window.solana.disconnect();
    }
  } catch (err) {
    console.warn("Manual disconnect error:", err);
  }

  // Reset UI and storage
  localStorage.removeItem("phantomWallet");
  walletDisplay.textContent = "Not Connected";
  connectBtn.textContent = "Connect Wallet";
  connectBtn.dataset.connected = "false";
  connectBtn.disabled = false;
  connectBtn.style.opacity = 1;
  console.log("Wallet disconnected.");
}

// --- Click Toggle (Connect / Disconnect) ---
connectBtn.addEventListener("click", async () => {
  const isConnected = connectBtn.dataset.connected === "true";
  if (isConnected) {
    await disconnectPhantom();
  } else {
    await connectPhantom();
  }
});

// --- Auto-load if previously connected ---
window.addEventListener("load", async () => {
  const saved = localStorage.getItem("phantomWallet");

  if (window.solana && window.solana.isPhantom) {
    const provider = window.solana;

    const alreadyConnected = await provider.connect({ onlyIfTrusted: true }).catch(() => null);
    if (alreadyConnected && alreadyConnected.publicKey) {
      const address = alreadyConnected.publicKey.toString();
      walletDisplay.textContent = address.slice(0, 4) + "..." + address.slice(-4);
      connectBtn.textContent = "Disconnect ‚ùå";
      connectBtn.dataset.connected = "true";
      connectBtn.style.opacity = 0.8;
      localStorage.setItem("phantomWallet", address);
    } else if (saved) {
      walletDisplay.textContent = saved.slice(0, 4) + "..." + saved.slice(-4);
      connectBtn.textContent = "Connect Wallet";
      connectBtn.dataset.connected = "false";
    }
  } else {
    walletDisplay.textContent = "No Phantom Detected";
  }
});
</script>

<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

<script src="script.js"></script>
</body>
</html>


