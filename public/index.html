<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RetardioStrategy™ Dashboard</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <!-- Video background (very back layer - BLACK TV SCREEN) -->
  <!-- muted is REQUIRED for autoplay to work in modern browsers -->
  <!-- playsinline is REQUIRED for iOS devices -->
  <video
    id="bgVideo"
    autoplay
    muted
    loop
    playsinline
    preload="metadata"
    style="
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: -2;
      opacity: 0.5;
      pointer-events: none;
      background: #000000;
    "
  >
    <source src="retardiovid.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video>

  <script>
    // Mobile detection - hide video on mobile devices
    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
        || window.innerWidth < 768;
    }

    // Force video to play (DESKTOP ONLY) - BLACK TV SCREEN BACKGROUND
    document.addEventListener('DOMContentLoaded', function() {
      const video = document.getElementById('bgVideo');

      if (video) {
        // Hide video on mobile devices
        if (isMobileDevice()) {
          console.log('[VIDEO] Mobile device detected - hiding video');
          video.style.display = 'none';
          return;
        }

        console.log('[VIDEO] Desktop device - attempting to play background video on BLACK TV SCREEN...');

        // Ensure video is ready
        video.load(); // Force reload

        // Try to play immediately
        const attemptPlay = () => {
          video.play().then(() => {
            console.log('[VIDEO] ✅ Video is playing on BLACK TV SCREEN background');
            console.log('[VIDEO] Current time:', video.currentTime, 'Duration:', video.duration);
          }).catch(err => {
            console.error('[VIDEO] ❌ Failed to play:', err.message);
            console.log('[VIDEO] Will retry on user interaction...');

            // Try again on user interaction
            const playOnce = () => {
              video.play().then(() => {
                console.log('[VIDEO] ✅ Video started after user interaction');
              }).catch(e => console.error('[VIDEO] Still failed:', e.message));
            };

            document.addEventListener('click', playOnce, { once: true });
            document.addEventListener('touchstart', playOnce, { once: true });
            document.addEventListener('keydown', playOnce, { once: true });
          });
        };

        // Try to play when metadata is loaded
        video.addEventListener('loadedmetadata', () => {
          console.log('[VIDEO] Metadata loaded, attempting play...');
          attemptPlay();
        });

        // Try to play when data is loaded
        video.addEventListener('loadeddata', () => {
          console.log('[VIDEO] Video data loaded');
          if (video.paused) {
            attemptPlay();
          }
        });

        // Log when video can play
        video.addEventListener('canplay', () => {
          console.log('[VIDEO] Video can play - duration:', video.duration, 'seconds');
          if (video.paused) {
            attemptPlay();
          }
        });

        // Monitor playing state
        video.addEventListener('playing', () => {
          console.log('[VIDEO] ✅ Video is now playing on BLACK TV SCREEN');
        });

        video.addEventListener('pause', () => {
          console.log('[VIDEO] ⚠️ Video paused - attempting to resume...');
          if (video.readyState >= 2) {
            attemptPlay();
          }
        });

        video.addEventListener('error', (e) => {
          console.error('[VIDEO] ❌ Video error:', e);
          if (video.error) {
            console.error('[VIDEO] Error code:', video.error.code, 'Message:', video.error.message);
          }
        });

        // Initial play attempt
        if (video.readyState >= 2) {
          attemptPlay();
        }
      }
    });
  </script>

  <!-- Particle background -->
  <canvas id="orbCanvas"></canvas>

  <!-- === Phantom Connect Button === -->
  <div id="wallet-connect-container">
    <button id="connect-wallet-btn">Connect Wallet</button>
    <p id="wallet-address-display"></p>
  </div>

<!-- === Follow X Button === -->
<div id="follow-x-container">
  <button id="follow-x-btn" onclick="window.open('https://x.com/retardioostr', '_blank')">
    Follow X
  </button>

  <!-- === Lobby Button === -->
  <button id="lobby-btn" class="lobby-btn" onclick="window.location.href='lobby.html'">
    🎮 live lobby
  </button>

 <!-- === Aesthetic Non-Functional Button === -->
  <button class="aesthetic-btn" disabled>Compatible for all devices</button>
</div>


  <div class="dashboard">
    <!-- Space Invaders game canvas inside dashboard -->
    <canvas id="dashboardGameCanvas"></canvas>

    <h1>RetardioStrategy™</h1>
    <h2>NFTStrategy (Solana Edition)</h2>
    <p class="contract">Contract: <span id="contract">Coming soon...</span></p>


<!-- === Project Description === -->
<div class="project-description">
  <img src="retardiologo.png" alt="$RTRDSTR Logo" class="project-logo" />
  <p>
    <strong>$RTRDSTR Machine</strong><br>
    Built on the Solana blockchain, the $RTRDSTR Machine powers the RETARDIO NFT ecosystem. 
    Creator fees generated by the $RTRDSTR token will be used to purchase RETARDIO NFTs from the floor. 
    These NFTs will then be relisted at <strong>1.2×</strong> the purchase price. 
    Proceeds from the sales will be used to buy back and burn $RTRDSTR tokens, supporting 
    <strong>deflationary tokenomics</strong>.
  </p>
</div>


    <!-- === Stats === -->
    <div class="stats">
      <div class="stat"><span class="label">Holding</span><span id="holding">0 Retardios</span></div>
      <div class="stat"><span class="label">SOL Price</span><span id="sol-price">$0.00</span></div>
      <div class="stat"><span class="label">$RTRDSTR Price</span><span id="token-price">$0.0000</span></div>
      <div class="stat"><span class="label">Market Cap</span><span id="real-market-cap">$0.00M</span></div>
      <div class="stat"><span class="label">Liquidity</span><span id="market-cap">$0.00M</span></div>
      <div class="stat"><span class="label">24h Change</span><span id="change">-0.00%</span></div>
    </div>

    <!-- === Treasury Section === -->
    <div class="treasury">
      <h3>Treasury Holdings</h3>
      <p>Treasury: <a id="Treasury" href="#" target="_blank">Insert wallet address here</a></p>
      <p>NFTs held: <span id="nft-count">0</span></p>
    </div>

 <!-- === Progress Section === -->
<div class="progress-section">
  <h3>Progress to Next Purchase</h3>

  <!-- Hidden input for Next Purchase uploads -->
  <input type="file" id="next-nft-upload" accept="image/*" style="display:none">

  <!-- Where the uploaded NFT will appear -->
  <div id="next-nft-preview" class="next-nft">
    <p>No next NFT uploaded yet.</p>
  </div>

  <div class="progress-bar">
    <div class="progress-fill" id="progress-fill" style="width: 0%;"></div>
  </div>

  <p id="progress-percent">0%</p>

  <p>
    When the machine acquires the missing
    <span id="missing-sol">0.0000</span> SOL, the entity to trigger the mechanism will process
    the purchase from floor price, which will be held by the treasury and relisted.
  </p>

  <p><strong>Need:</strong> <span id="need-sol">0.000</span> more SOL</p>
</div>



<iframe
  id="gecko-frame"
  src="https://www.geckoterminal.com/solana/pools/5eLRsN6qDQTQSBF8KdW4B8mVpeeAzHCCwaDptzMyszxH?embed=1"
  width="100%"
  height="500"
  style="border:0; border-radius:12px; overflow:hidden;"
  allowfullscreen
></iframe>




   <!-- === Treasury NFT Gallery === -->
   <div class="gallery">
     <div class="gallery-header">
       <h3>Treasury NFT Gallery</h3>
       <a href="https://magiceden.io/marketplace/retardio_cousins" target="_blank">
         <img src="magiceden-logo.png" alt="Magic Eden" class="magic-eden-logo" />
       </a>
     </div>

     <p id="gallery-summary">RetardioStrategy™ is currently holding 0 NFTs</p>
     <input type="file" id="nft-upload" accept="image/*" style="display:none" multiple />
     <div id="gallery-grid" class="gallery-grid"></div>
   </div>

   <!-- === Token Loader (Hidden) === -->
   <div id="token-loader" style="display:none; margin:20px 0;">
     <label for="token-contract">Paste DexScreener/Token CA:</label>
     <input type="text" id="token-contract" placeholder="Enter contract address or token symbol" />
     <button id="load-token">Load Token</button>
   </div>

   <!-- === Dev Panel (Hidden by Default) === -->
   <div id="dev-panel" style="display:none;">
     <button id="u1" class="dev-btn">u1</button>
     <button id="s1" class="dev-btn">s1</button>
     <button id="pa" class="dev-btn">pa</button>
     <button id="np" class="dev-btn">NP</button>
     <button id="ba" class="dev-btn">BA</button> <!-- 🔥 Burn Amount -->
   </div>

 <!-- === Sold NFT Gallery === -->
<div class="gallery sold-gallery">
  <div class="gallery-header">
    <h3>Sold NFTs</h3>
  </div>

  <p id="sold-summary">RetardioStrategy™ has sold 0 NFTs</p>
 <p>Burned Amount: <span id="burned-percent">0%</span></p>
  <input type="file" id="sold-upload" accept="image/*" style="display:none" multiple />
  <div id="sold-gallery-grid" class="gallery-grid"></div>
</div>


<!-- === JS === -->
<script>

async function loadPoolChart() {
  try {
    const ohlcvRes = await fetch(
      `https://api.geckoterminal.com/api/v2/networks/solana/pools/${poolId}/ohlcv/hour`
    );

    if (ohlcvRes.status === 404) {
      console.warn("No OHLCV data for this pool — showing current price instead");
      const poolRes = await fetch(
        `https://api.geckoterminal.com/api/v2/networks/solana/pools/${poolId}`
      );
      const poolData = await poolRes.json();
      const price = poolData?.data?.attributes?.base_token_price_usd;
      chartDiv.innerHTML = `<div style="font-size:2rem;color:#ff4fd8;text-align:center;">$${Number(price).toFixed(4)}</div>`;
      return;
    }

    if (!ohlcvRes.ok) throw new Error(`HTTP ${ohlcvRes.status}`);
    const data = await ohlcvRes.json();
    const prices = data?.data?.attributes?.ohlcv_list;

    if (!prices) throw new Error("No OHLCV data");

    const chartData = prices.map(([timestamp, open, high, low, close]) => ({
      time: Math.floor(new Date(timestamp).getTime() / 1000),
      open: +open,
      high: +high,
      low: +low,
      close: +close
    }));

    candleSeries.setData(chartData);
  } catch (err) {
    chartDiv.innerHTML = "⚠️ Failed to load chart.";
    console.error("Error loading chart:", err);
  }
}

// === Dev Unlock (Ctrl+D) ===
window.addEventListener("keydown", async (e) => {
  if (e.ctrlKey && e.key.toLowerCase() === "d") {
    const key = prompt("Enter developer key:");
    if (!key) return;

    try {
      const res = await fetch("/verify-dev", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ key }),
      });
      const data = await res.json();

      if (data.valid) {
        devUnlocked = true;
        window.devUnlocked = true; // ✅ Sync with window global
        localStorage.setItem("devKey", key); // ✅ Save for API calls
        document.getElementById("dev-panel").style.display = "flex";
        alert("Developer mode unlocked 🔓");

        // ✅ Reload galleries to show delete buttons
        if (typeof loadGallery === "function") loadGallery();
        if (typeof loadSoldGallery === "function") loadSoldGallery();

        // ✅ Reload next purchase NFT to show delete button
        if (typeof loadGlobalState === "function") {
          loadGlobalState().then(() => {
            console.log("✅ Next purchase NFT reloaded with delete button");
          });
        }
      } else {
        alert("Access denied 🚫");
      }
    } catch (err) {
      console.error("Dev verify failed:", err);
      alert("Server error ❌");
    }
  }
});

// === u1 (Upload Treasury NFTs - GLOBAL) ===
document.getElementById("u1").addEventListener("click", () => {
  if (!devUnlocked) return alert("🚫 Developer mode required.");
  const fileInput = document.getElementById("nft-upload");
  fileInput.click();

  fileInput.onchange = async () => {
    const formData = new FormData();

    for (const file of fileInput.files) {
      const name = prompt("Enter NFT Name:");
      const price = prompt("Enter Listing Price (SOL):");
      const magicEdenUrl = prompt("Enter Magic Eden item URL (optional):", "https://magiceden.io/item-details/");

      formData.append("images", file);
      formData.append(
        "meta",
        JSON.stringify({ name, price, magicEdenUrl })
      );
    }

    const res = await fetch("/upload-gallery", {
      method: "POST",
      body: formData,
    });
    const data = await res.json();

    if (data.success) {
      alert("✅ Treasury NFT uploaded globally!");
      loadGallery();
    } else {
      alert("❌ Upload failed.");
    }
  };
});


  // === s1 (Upload Sold NFTs - GLOBAL) ===
  document.getElementById("s1").addEventListener("click", () => {
    if (!devUnlocked) return alert("🚫 Developer mode required.");
    const fileInput = document.getElementById("sold-upload");
    fileInput.click();
    fileInput.onchange = async () => {
      const formData = new FormData();
      for (const file of fileInput.files) {
        const name = prompt("Enter Sold NFT Name:");
        const price = prompt("Enter Sold Price (SOL):");
        formData.append("images", file);
        formData.append("meta", JSON.stringify({ name, price }));
      }
      const res = await fetch("/upload-sold", { method: "POST", body: formData });
      const data = await res.json();
      if (data.success) {
        alert("✅ Sold NFT uploaded globally!");
        loadSoldGallery();
      } else {
        alert("❌ Upload failed.");
      }
    };
  });

// === BA (Burn Amount - Set Burned % Display) ===
document.getElementById("ba").addEventListener("click", async () => {
  if (!devUnlocked) return alert("🚫 Developer mode required.");

  // Ask the dev for a burn % (number only)
  const value = prompt("Enter Burned Percentage (0-100):", "0");
  if (value === null) return; // cancelled
  const percent = parseFloat(value);

  if (isNaN(percent) || percent < 0 || percent > 100) {
    alert("❌ Invalid value. Please enter a number between 0 and 100.");
    return;
  }

  // Update UI immediately
  document.getElementById("burned-percent").textContent = `${percent}% 🔥`;

  alert(`🔥 Burn percentage updated to ${percent}%`);

  // ✅ Save globally on the server so everyone sees the same burn %
  try {
    const res = await fetch("/update-state", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        key: localStorage.getItem("devKey"),
        updates: { burnPercent: percent }
      })
    });

    const data = await res.json();
    if (!data.success) console.warn("⚠️ Burn update failed:", data);
  } catch (err) {
    console.error("❌ Error updating global burn percent:", err);
  }
});



function launchConfetti() {
  const duration = 10000;
  const animationEnd = Date.now() + duration;
  const defaults = { startVelocity: 25, spread: 360, ticks: 60, zIndex: 9999 };

  function randomInRange(min, max) {
    return Math.random() * (max - min) + min;
  }

  (function frame() {
    // Use a CDN-free version if you already have canvas-confetti
    if (typeof confetti === "function") {
      confetti({
        ...defaults,
        particleCount: 50,
        origin: {
          x: randomInRange(0.1, 0.9),
          y: Math.random() - 0.2,
        },
      });
    }
    if (Date.now() < animationEnd) {
      requestAnimationFrame(frame);
    }
  })();
}


  // === RETRO GAME BACKGROUND ===
  const canvas = document.getElementById("orbCanvas");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();

  // Retro arcade color palette
  const retroColors = [
    { color: "#00FFFF", glow: "#00FFFF" }, // Cyan
    { color: "#FF00FF", glow: "#FF00FF" }, // Magenta
    { color: "#FFFF00", glow: "#FFFF00" }, // Yellow
    { color: "#00FF00", glow: "#00FF00" }, // Green
    { color: "#FF4FD8", glow: "#FF4FD8" }, // Pink
    { color: "#14F195", glow: "#14F195" }  // Solana green
  ];

  // Pixel block class (retro game style)
  class PixelBlock {
    constructor() {
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.size = 20 + Math.floor(Math.random() * 4) * 10; // Pixelated sizes
      this.dx = (Math.random() - 0.5) * 1.2;
      this.dy = (Math.random() - 0.5) * 1.2;
      this.opacity = 0.15 + Math.random() * 0.25;
      this.rotation = 0;
      this.rotationSpeed = (Math.random() - 0.5) * 0.02;

      const chosen = retroColors[Math.floor(Math.random() * retroColors.length)];
      this.baseColor = chosen.color;
      this.glowColor = chosen.glow;
      this.shape = Math.floor(Math.random() * 3); // 0=square, 1=diamond, 2=plus
    }

    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);

      ctx.shadowColor = this.glowColor;
      ctx.shadowBlur = 30;

      const rgba = this.hexToRgba(this.baseColor, this.opacity);
      ctx.fillStyle = rgba;
      ctx.strokeStyle = this.hexToRgba(this.baseColor, this.opacity + 0.2);
      ctx.lineWidth = 2;

      if (this.shape === 0) {
        // Square
        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
        ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
      } else if (this.shape === 1) {
        // Diamond
        ctx.beginPath();
        ctx.moveTo(0, -this.size/2);
        ctx.lineTo(this.size/2, 0);
        ctx.lineTo(0, this.size/2);
        ctx.lineTo(-this.size/2, 0);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      } else {
        // Plus/Cross
        const thick = this.size / 4;
        ctx.fillRect(-this.size/2, -thick/2, this.size, thick);
        ctx.fillRect(-thick/2, -this.size/2, thick, this.size);
        ctx.strokeRect(-this.size/2, -thick/2, this.size, thick);
        ctx.strokeRect(-thick/2, -this.size/2, thick, this.size);
      }

      ctx.restore();
    }

    update() {
      this.x += this.dx;
      this.y += this.dy;
      this.rotation += this.rotationSpeed;

      if (this.x < -50 || this.x > canvas.width + 50) this.dx *= -1;
      if (this.y < -50 || this.y > canvas.height + 50) this.dy *= -1;

      this.draw();
    }

    hexToRgba(hex, alpha) {
      const bigint = parseInt(hex.slice(1), 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
  }

  // Starfield effect
  class Star {
    constructor() {
      this.reset();
    }

    reset() {
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.z = Math.random() * canvas.width;
      this.speed = 0.5 + Math.random() * 1.5;
    }

    update() {
      this.z -= this.speed;
      if (this.z <= 0) this.reset();
    }

    draw() {
      const x = (this.x - canvas.width / 2) * (canvas.width / this.z);
      const y = (this.y - canvas.height / 2) * (canvas.width / this.z);
      const s = (1 - this.z / canvas.width) * 2;

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      ctx.fillStyle = `rgba(255, 255, 255, ${1 - this.z / canvas.width})`;
      ctx.fillRect(centerX + x, centerY + y, s, s);
    }
  }

  const blocks = Array.from({ length: 4 }, () => new PixelBlock()); // Reduced from 8 for performance
  const stars = Array.from({ length: 15 }, () => new Star()); // Reduced from 30 for performance
  let gridOffset = 0;

  // === DVD BOUNCING BOX (Classic Screensaver Style) ===
  class DVDBouncingBox {
    constructor() {
      this.width = 120;
      this.height = 80;
      this.x = Math.random() * (canvas.width - this.width);
      this.y = Math.random() * (canvas.height - this.height);
      this.dx = 2 + Math.random() * 2;
      this.dy = 2 + Math.random() * 2;

      // Rainbow colors for DVD effect
      this.colors = [
        '#FF0000', // Red
        '#FF7F00', // Orange
        '#FFFF00', // Yellow
        '#00FF00', // Green
        '#00FFFF', // Cyan
        '#0000FF', // Blue
        '#8B00FF', // Purple
        '#FF00FF'  // Magenta
      ];
      this.colorIndex = Math.floor(Math.random() * this.colors.length);
    }

    changeColor() {
      this.colorIndex = (this.colorIndex + 1) % this.colors.length;
    }

    draw() {
      this.x += this.dx;
      this.y += this.dy;

      // Bounce off edges and change color
      if (this.x <= 0 || this.x + this.width >= canvas.width) {
        this.dx *= -1;
        this.changeColor();
      }
      if (this.y <= 0 || this.y + this.height >= canvas.height) {
        this.dy *= -1;
        this.changeColor();
      }

      // Keep within bounds
      this.x = Math.max(0, Math.min(this.x, canvas.width - this.width));
      this.y = Math.max(0, Math.min(this.y, canvas.height - this.height));

      ctx.save();

      // Draw glowing box
      const currentColor = this.colors[this.colorIndex];
      ctx.shadowColor = currentColor;
      ctx.shadowBlur = 30;

      // Outer glow
      ctx.fillStyle = currentColor + '40'; // 25% opacity
      ctx.fillRect(this.x - 10, this.y - 10, this.width + 20, this.height + 20);

      // Main box
      ctx.fillStyle = currentColor + 'CC'; // 80% opacity
      ctx.fillRect(this.x, this.y, this.width, this.height);

      // Border
      ctx.strokeStyle = currentColor;
      ctx.lineWidth = 3;
      ctx.strokeRect(this.x, this.y, this.width, this.height);

      // DVD text style
      ctx.fillStyle = '#000000';
      ctx.font = 'bold 24px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('DVD', this.x + this.width / 2, this.y + this.height / 2);

      ctx.restore();
    }
  }

  // === ARCADE GAME ELEMENTS (Mario/DK style) ===
  class ArcadeCoin {
    constructor() {
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.size = 20;
      this.floatOffset = Math.random() * Math.PI * 2;
      this.floatSpeed = 0.02 + Math.random() * 0.02;
      this.baseY = this.y;
      this.rotation = 0;
    }

    draw() {
      this.floatOffset += this.floatSpeed;
      this.y = this.baseY + Math.sin(this.floatOffset) * 30;
      this.rotation += 0.05;

      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);

      // Gold coin
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
      gradient.addColorStop(0, '#FFD700');
      gradient.addColorStop(0.5, '#FFA500');
      gradient.addColorStop(1, '#FF8C00');

      ctx.shadowColor = '#FFD700';
      ctx.shadowBlur = 15;
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
      ctx.fill();

      // Coin detail
      ctx.strokeStyle = '#FFFF00';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.restore();
    }
  }

  class QuestionBlock {
    constructor() {
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.size = 30;
      this.floatOffset = Math.random() * Math.PI * 2;
      this.floatSpeed = 0.015;
      this.baseY = this.y;
      this.pulseOffset = 0;
    }

    draw() {
      this.floatOffset += this.floatSpeed;
      this.y = this.baseY + Math.sin(this.floatOffset) * 20;
      this.pulseOffset += 0.05;
      const pulse = 1 + Math.sin(this.pulseOffset) * 0.1;

      ctx.save();
      ctx.translate(this.x, this.y);

      // Question block
      ctx.shadowColor = '#FFD700';
      ctx.shadowBlur = 20 * pulse;

      const gradient = ctx.createLinearGradient(-this.size/2, -this.size/2, this.size/2, this.size/2);
      gradient.addColorStop(0, '#FFD700');
      gradient.addColorStop(0.5, '#FFA500');
      gradient.addColorStop(1, '#FF8C00');

      ctx.fillStyle = gradient;
      ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);

      // Border
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 3;
      ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);

      // Question mark
      ctx.fillStyle = '#FFFF00';
      ctx.font = 'bold 20px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('?', 0, 0);

      ctx.restore();
    }
  }

  class Barrel {
    constructor() {
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.size = 25;
      this.dx = (Math.random() - 0.5) * 0.5;
      this.dy = (Math.random() - 0.5) * 0.5;
      this.rotation = 0;
    }

    draw() {
      this.x += this.dx;
      this.y += this.dy;
      this.rotation += 0.02;

      if (this.x < 0 || this.x > canvas.width) this.dx *= -1;
      if (this.y < 0 || this.y > canvas.height) this.dy *= -1;

      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);

      // Barrel body
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);

      // Barrel bands
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-this.size/2, -this.size/4);
      ctx.lineTo(this.size/2, -this.size/4);
      ctx.moveTo(-this.size/2, this.size/4);
      ctx.lineTo(this.size/2, this.size/4);
      ctx.stroke();

      ctx.restore();
    }
  }

  // === SPACE INVADERS CLASS ===
  class SpaceInvader {
    constructor() {
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.size = 25;
      this.dx = (Math.random() - 0.5) * 0.8;
      this.dy = (Math.random() - 0.5) * 0.3;
      this.animFrame = 0;
      this.animSpeed = 0.1;
      this.type = Math.floor(Math.random() * 3); // 3 alien types
      this.color = ['#00FF00', '#FF00FF', '#00FFFF'][this.type];
    }

    draw() {
      this.x += this.dx;
      this.y += this.dy;
      this.animFrame += this.animSpeed;

      // Bounce off edges
      if (this.x < 0 || this.x > canvas.width) this.dx *= -1;
      if (this.y < 0 || this.y > canvas.height) this.dy *= -1;

      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.fillStyle = this.color;
      ctx.shadowColor = this.color;
      ctx.shadowBlur = 15;

      const frame = Math.floor(this.animFrame) % 2;
      const s = this.size / 8;

      // Draw classic Space Invader sprite (pixelated)
      if (this.type === 0) {
        // Squid alien
        const pattern = frame === 0
          ? [[0,0,1,0,0,0,0,0,1,0,0],
             [0,0,0,1,0,0,0,1,0,0,0],
             [0,0,1,1,1,1,1,1,1,0,0],
             [0,1,1,0,1,1,1,0,1,1,0],
             [1,1,1,1,1,1,1,1,1,1,1],
             [1,0,1,1,1,1,1,1,1,0,1],
             [1,0,1,0,0,0,0,0,1,0,1],
             [0,0,0,1,1,0,1,1,0,0,0]]
          : [[0,0,1,0,0,0,0,0,1,0,0],
             [1,0,0,1,0,0,0,1,0,0,1],
             [1,0,1,1,1,1,1,1,1,0,1],
             [1,1,1,0,1,1,1,0,1,1,1],
             [1,1,1,1,1,1,1,1,1,1,1],
             [0,1,1,1,1,1,1,1,1,1,0],
             [0,0,1,0,0,0,0,0,1,0,0],
             [0,1,0,0,0,0,0,0,0,1,0]];
        this.drawPattern(pattern, s);
      } else if (this.type === 1) {
        // Crab alien
        const pattern = frame === 0
          ? [[0,0,1,0,0,0,0,0,1,0,0],
             [0,0,0,1,0,0,0,1,0,0,0],
             [0,0,1,1,1,1,1,1,1,0,0],
             [0,1,1,0,1,1,1,0,1,1,0],
             [1,1,1,1,1,1,1,1,1,1,1],
             [1,0,1,1,1,1,1,1,1,0,1],
             [1,0,1,0,0,0,0,0,1,0,1],
             [0,0,0,1,1,0,1,1,0,0,0]]
          : [[0,0,1,0,0,0,0,0,1,0,0],
             [1,0,0,1,0,0,0,1,0,0,1],
             [1,0,1,1,1,1,1,1,1,0,1],
             [1,1,1,0,1,1,1,0,1,1,1],
             [1,1,1,1,1,1,1,1,1,1,1],
             [0,1,1,1,1,1,1,1,1,1,0],
             [0,0,1,0,0,0,0,0,1,0,0],
             [0,1,0,0,0,0,0,0,0,1,0]];
        this.drawPattern(pattern, s);
      } else {
        // Octopus alien
        const pattern = frame === 0
          ? [[0,0,0,0,1,1,1,1,0,0,0,0],
             [0,1,1,1,1,1,1,1,1,1,1,0],
             [1,1,1,1,1,1,1,1,1,1,1,1],
             [1,1,1,0,0,1,1,0,0,1,1,1],
             [1,1,1,1,1,1,1,1,1,1,1,1],
             [0,0,1,1,1,0,0,1,1,1,0,0],
             [0,1,1,0,0,1,1,0,0,1,1,0],
             [1,1,0,0,0,0,0,0,0,0,1,1]]
          : [[0,0,0,0,1,1,1,1,0,0,0,0],
             [0,1,1,1,1,1,1,1,1,1,1,0],
             [1,1,1,1,1,1,1,1,1,1,1,1],
             [1,1,1,0,0,1,1,0,0,1,1,1],
             [1,1,1,1,1,1,1,1,1,1,1,1],
             [0,0,0,1,1,0,0,1,1,0,0,0],
             [0,0,1,1,0,1,1,0,1,1,0,0],
             [0,0,1,1,0,0,0,0,1,1,0,0]];
        this.drawPattern(pattern, s);
      }

      ctx.restore();
    }

    drawPattern(pattern, pixelSize) {
      const offsetX = -(pattern[0].length * pixelSize) / 2;
      const offsetY = -(pattern.length * pixelSize) / 2;

      for (let row = 0; row < pattern.length; row++) {
        for (let col = 0; col < pattern[row].length; col++) {
          if (pattern[row][col] === 1) {
            ctx.fillRect(
              offsetX + col * pixelSize,
              offsetY + row * pixelSize,
              pixelSize,
              pixelSize
            );
          }
        }
      }
    }
  }

  // Create arcade elements (heavily optimized for performance)
  const dvdBox = new DVDBouncingBox(); // The iconic bouncing DVD box!
  const coins = Array.from({ length: 2 }, () => new ArcadeCoin()); // Reduced from 3
  const questionBlocks = Array.from({ length: 1 }, () => new QuestionBlock()); // Reduced from 2
  const barrels = []; // Disabled for performance
  const spaceInvaders = Array.from({ length: 2 }, () => new SpaceInvader()); // Reduced from 4 for performance

  function drawGrid() {
    const gridSize = 40;
    ctx.strokeStyle = "rgba(0, 255, 255, 0.05)";
    ctx.lineWidth = 1;

    // Animated vertical lines
    for (let x = (gridOffset % gridSize); x < canvas.width; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }

    // Animated horizontal lines
    for (let y = (gridOffset % gridSize); y < canvas.height; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }

    gridOffset += 0.3; // Slow scroll
  }

  // Optimized scanlines - draw less frequently
  let scanlineFrame = 0;
  function drawScanlines() {
    scanlineFrame++;
    if (scanlineFrame % 2 !== 0) return; // Only draw every other frame

    ctx.strokeStyle = "rgba(0, 255, 0, 0.03)";
    ctx.lineWidth = 1;
    for (let i = 0; i < canvas.height; i += 6) { // Increased spacing from 4 to 6
      ctx.beginPath();
      ctx.moveTo(0, i);
      ctx.lineTo(canvas.width, i);
      ctx.stroke();
    }
  }

  // Optimized animation loop with requestAnimationFrame throttling
  let lastTime = 0;
  const fps = 60;
  const frameInterval = 1000 / fps;

  function animate(currentTime = 0) {
    const deltaTime = currentTime - lastTime;

    // Throttle to target FPS for smoother performance
    if (deltaTime < frameInterval) {
      requestAnimationFrame(animate);
      return;
    }

    lastTime = currentTime - (deltaTime % frameInterval);

    // Dark retro background (very transparent to show video)
    ctx.fillStyle = "rgba(5, 0, 15, 0.05)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw starfield
    stars.forEach(star => {
      star.update();
      star.draw();
    });

    // Draw grid
    drawGrid();

    // Draw the iconic DVD bouncing box FIRST (behind everything)
    dvdBox.draw();

    // Draw pixel blocks
    blocks.forEach(block => block.update());

    // Draw arcade game elements (Mario/DK style)
    coins.forEach(coin => coin.draw());
    questionBlocks.forEach(block => block.draw());
    barrels.forEach(barrel => barrel.draw());

    // Draw Space Invaders aliens
    spaceInvaders.forEach(invader => invader.draw());

    // Add scanlines for CRT effect (optimized)
    drawScanlines();

    requestAnimationFrame(animate);
  }

  animate();
  window.addEventListener("resize", resizeCanvas);
</script>

<!-- === Phantom Wallet Connect === -->
<script>
const connectBtn = document.getElementById("connect-wallet-btn");
const walletDisplay = document.getElementById("wallet-address-display");

// --- Connect Phantom ---
async function connectPhantom() {
  try {
    if (!window.solana || !window.solana.isPhantom) {
      alert("Phantom Wallet not found. Please install it from https://phantom.app/");
      return;
    }

    const resp = await window.solana.connect();
    const address = resp.publicKey.toString();

    walletDisplay.textContent = address.slice(0, 4) + "..." + address.slice(-4);
    connectBtn.textContent = "Disconnect ❌";
    connectBtn.dataset.connected = "true"; // Track connection state
    connectBtn.style.opacity = 0.8;

    localStorage.setItem("phantomWallet", address);
    console.log("Connected wallet:", address);
  } catch (err) {
    console.error("Connection failed:", err);
    alert("Wallet connection failed or rejected.");
  }
}

// --- Disconnect Phantom ---
async function disconnectPhantom() {
  try {
    if (window.solana && window.solana.isPhantom) {
      await window.solana.disconnect();
    }
  } catch (err) {
    console.warn("Manual disconnect error:", err);
  }

  // Reset UI and storage
  localStorage.removeItem("phantomWallet");
  walletDisplay.textContent = "Not Connected";
  connectBtn.textContent = "Connect Wallet";
  connectBtn.dataset.connected = "false";
  connectBtn.disabled = false;
  connectBtn.style.opacity = 1;
  console.log("Wallet disconnected.");
}

// --- Click Toggle (Connect / Disconnect) ---
connectBtn.addEventListener("click", async () => {
  const isConnected = connectBtn.dataset.connected === "true";
  if (isConnected) {
    await disconnectPhantom();
  } else {
    await connectPhantom();
  }
});

// --- Auto-load if previously connected ---
window.addEventListener("load", async () => {
  const saved = localStorage.getItem("phantomWallet");

  if (window.solana && window.solana.isPhantom) {
    const provider = window.solana;

    const alreadyConnected = await provider.connect({ onlyIfTrusted: true }).catch(() => null);
    if (alreadyConnected && alreadyConnected.publicKey) {
      const address = alreadyConnected.publicKey.toString();
      walletDisplay.textContent = address.slice(0, 4) + "..." + address.slice(-4);
      connectBtn.textContent = "Disconnect ❌";
      connectBtn.dataset.connected = "true";
      connectBtn.style.opacity = 0.8;
      localStorage.setItem("phantomWallet", address);
    } else if (saved) {
      walletDisplay.textContent = saved.slice(0, 4) + "..." + saved.slice(-4);
      connectBtn.textContent = "Connect Wallet";
      connectBtn.dataset.connected = "false";
    }
  } else {
    walletDisplay.textContent = "No Phantom Detected";
  }
});
</script>

<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
<script src="/socket.io/socket.io.js"></script>

<script src="script.js"></script>
</body>
</html>

 
